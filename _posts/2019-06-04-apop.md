---
title: "Learning #9: The APOP Programming Language"
updated: 2019-06-03 12:00
---

Believe it or not, I changed my mind again. I know, I know, I know... stick to one thing.

![face palm](https://media.giphy.com/media/6yRVg0HWzgS88/giphy.gif)

However, I just could not get myself to reimplement another version of the semi-object-oriented Sailfish Programming Language. It is so boring and it's really time to try a LISP.

So, without further ado, I present APOP. APOP stands for **(A)** **(P)**lethora **(O)**f **(P)**arentheses. This language will start extremely simple, basically an implementation of the simplified version of Scheme used in [The Little Lisper](https://mitpress.mit.edu/books/little-lisper-trade-edition) and then will expand once I am 100% sure it actually works correctly (versus Sailfish which never has worked 100% correctly, or even 80% correctly).

***

## Grammar and Such

Instead of just banging away at the keys (a skill I have picked up from work), I decided it would be best to get my thoughts down on paper (read markdown). Thus, today I wrote out a rough draft of the grammar, the lexicon, and some of the foundational functions that will ship with the APOP compiler.

### Lexicon

Quoted from the APOP docs:

*The Lexicon of APOP consists of all the characters common in English, uppercase and lowercase, all number characters, parenthesis, a question mark only if it is prefaced by at least one character and followed by a whitespace, and finally hashmarks only if followed by a 't' or a 'f'.*

*The following are keywords:*

* def
* lambda
* cond


### Grammar

This grammar may seem overlysimplified... and it might be. I will see how this actually plays out when I get to implementing it (for Sailfish I changed the grammar considerably when I realized my first, second, and third drafts were not actually implementable in any shape or form).

```
Data := [Atom | List]

Definition := 'define' Data
Lambda := 'lambda' Data
Conditional := 'cond' Data

Atom := ''' [AlphaNumeric | Empty | List]
AlphaNumeric := Alpha | Numeric
Alpha        := [A-z][A-z?]*
Numeric      := [0-9]*
List         := '(' Data ')'

Boolean      := #t | #f
```

### Foundational Functions

I could only come up with a couple of these to start. However, there is no rush to figure this out... this is a very post backend sort of step.

So far what I have is:
<br>
**cons:** combine two elements <br>
**car:** return the first element from a list <br>
**eq?:** determine whether two bits of data are the same <br>

***

And that is about all I have today -- spent much longer on the blog post and learnings than I should have (and 30 minutes were wasted picking the name) ðŸ¤·. Off to the gym!

***